# Pages & routing

__Source code__: [GitHub](https://github.com/ryannhg/elm-spa/tree/main/examples/01-pages)

This next guide will show you how pages, routing, and the `elm-spa add` command work together to automatically handle URLs in your __elm-spa__ application.


### The setup

Just like with the last guide, we can use `elm-spa new` and `elm-spa server` to get a brand new __elm-spa__ project up and running:

```terminal
mkdir 02-pages
cd 02-pages

elm-spa new
elm-spa server
```

This generates the "Hello, world!" homepage from before:

![A browser displaying "Hello world"](/content/images/01-hello-world.png)

### Adding a static page

```terminal
elm-spa add /static static
```

This command adds a page at [http://localhost:1234/static](http://localhost:1234/static) with the `static` template. This is similar to `Home_.elm`, but it has access to `Shared.Model` and `Request` in case we need data from either of those.

Here is the complete `Static.elm` file:

```elm
module Pages.Static exposing (page)

import Page exposing (Page)
import Request exposing (Request)
import Shared
import View exposing (View)


page : Shared.Model -> Request -> Page
page shared req =
    Page.static
        { view = view
        }


view : View msg
view =
    View.placeholder "Static"
```

The `View.placeholder` function just stubs out the `view` function with an empty page that only renders "Static" in the browser.

Visit [http://localhost:1234/static](http://localhost:1234/static) to see it in action!

### Making a layout

Before we continue, I want to make a layout with a navbar so that we can easily navigate between pages without manually editing the URL.

I'll create a file at `src/UI.elm` that looks like this:

```elm
module UI exposing (layout)

import Html exposing (Html)
import Html.Attributes as Attr


layout : List (Html msg) -> List (Html msg)
layout children =
    let
        viewLink : String -> String -> Html msg
        viewLink label url =
            Html.a [ Attr.href url ] [ Html.text label ]
    in
    [ Html.div [ Attr.class "container" ]
        [ Html.header [ Attr.class "navbar" ]
            [ viewLink "Home" "/"
            , viewLink "Static" "/static"
            ]
        , Html.main_ [] children
        ]
    ]
```

### Using the layout in a page

Because it works from one `List (Html msg)` to another, we can add `UI.layout` in front of the `body` list on both pages:

```elm
-- src/Pages/Home_.elm

view : View msg
view =
    { title = "Homepage"
    , body = UI.layout [ Html.text "Homepage" ]
    }
```

```elm
-- src/Pages/Static.elm

view : View msg
view =
    { title = "Static"
    , body = UI.layout [ Html.text "Static" ]
    }
```

### Use routes, not strings

In `src/UI.elm`, we had a function for rendering our navbar links that looked like this:

```elm
viewLink : String -> String -> Html msg
viewLink label url =
    Html.a [ Attr.href url ] [ Html.text label ]
```

This function works great– but it's possible to provide a URL that our application doesn't have!

```elm
[ viewLink "Home" "/"
, viewLink "Static" "/satic"
]
```

Here, I mistyped the URL `/satic`, but the compiler didn't warn me about it! Let's use the `Route` values generated by __elm-spa__ to improve this experience:

```elm
import Gen.Route as Route exposing (Route)

viewLink : String -> Route -> Html msg
viewLink label route =
    Html.a [ Attr.href (Route.toHref route) ] [ Html.text label ]
```

By using the `Gen.Route` module from `.elm-spa/generated`, we can pass in a `Route` instead of a `String`:

```elm
[ viewLink "Home" Route.Home_ 
, viewLink "Static" Route.Static
]
```

This will prevent typos, but __more importantly__ it allows the Elm compiler to remind us to update the navbar in case we remove `Home_.elm` or `Static.elm` in the future.

Deleting either of those pages changes the generated `Gen.Route` module, so the compiler can let us know that our `UI.layout` function has a broken link– before our users do!

### Adding CSS

In `UI.layout`, we used `Attr.class` to provide our HTML with some CSS classes:

```elm
Html.div [ Attr.class "container" ]
    [ Html.header [ Attr.class "navbar" ]
        [ viewLink "Home" Route.Home_
        , viewLink "Static" Route.Static
        ]
    ]
```

The `container` and `navbar` classes are used in our code, but not defined in a CSS file. Let's fix that by creating a new CSS file at `public/style.css`:

```css
.container {
  max-width: 960px;
  margin: 1rem auto;
}

.navbar {
  display: flex;
  align-items: center;
}

.navbar a {
  margin-right: 16px;
}
```

After creating `style.css`, we can import the file in our `public/index.html` entrypoint:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- import our new CSS file -->
  <link rel="stylesheet" href="/style.css">

</head>
<body>
  <script src="/dist/elm.js"></script>
  <script> Elm.Main.init() </script>
</body>
</html>
```

Using the `<link>` tag as shown above (with the leading slash!) imports our CSS file. All files in the `public` folder are available at the root of our web application. That means a file stored at `public/images/dog.png` would be at `http://localhost:1234/images/dog`, without including `public` in the URL at all.


---

__Next up:__ [Storage](./03-storage)
